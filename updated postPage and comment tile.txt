updated postPage and comment tile 


import 'dart:async';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart'; // Haptic feedback
import 'package:provider/provider.dart';
import 'package:social_media/Components/glass_notification_tile.dart';
import 'package:social_media/Components/my_comment_tile.dart';
import 'package:social_media/Components/my_bottom_bar.dart';
import 'package:social_media/models/post.dart';
import 'package:social_media/models/comment.dart';
import 'package:social_media/services/database/database_provider.dart';

class PostPage extends StatefulWidget {
  final Post post;
  const PostPage({super.key, required this.post});

  @override
  State<PostPage> createState() => _PostPageState();
}

class _PostPageState extends State<PostPage> {
  final TextEditingController _controller = TextEditingController();
  final FocusNode _focusNode = FocusNode();

  bool _isPosting = false;
  Comment? _replyingTo;

  @override
  void initState() {
    super.initState();
    final db = Provider.of<DatabaseProvider>(context, listen: false);

    // Listen to comments of this post
    db.listenToComments(widget.post.id);

    // Listen to replies for each comment after initial load
    WidgetsBinding.instance.addPostFrameCallback((_) {
      final comments = db.getComments(widget.post.id);
      for (var comment in comments) {
        db.listenToReplies(comment.id);
      }
    });
  }

  @override
  void dispose() {
    _controller.dispose();
    _focusNode.dispose();
    super.dispose();
  }

  void _showNotification(String message) {
    GlassNotificationTile.show(context, message);
  }

  void _showCommentOptions(Comment comment, {String? parentCommentId}) {
    final currentUserId = FirebaseAuth.instance.currentUser?.uid;
    final isOwn = comment.uid == currentUserId;

    MyBottomBar.show(
      context: context,
      title: "Options",
      items: [
        if (isOwn)
          BottomBarItem(
            icon: Icons.delete,
            label: "Delete",
            onTap: () async {
              if (parentCommentId == null) {
                await _handleDeleteComment(comment);
              } else {
                await _handleDeleteReply(parentCommentId, comment);
              }
            },
          )
        else
          BottomBarItem(
            icon: Icons.report,
            label: "Report",
            onTap: () => _showNotification("Reported successfully"),
          ),
        BottomBarItem(
          icon: Icons.close,
          label: "Cancel",
          onTap: () {},
        ),
      ],
    );
  }

  Future<void> _submitCommentOrReply() async {
    if (_isPosting) return;
    final text = _controller.text.trim();
    if (text.isEmpty) return;

    setState(() => _isPosting = true);
    final db = Provider.of<DatabaseProvider>(context, listen: false);

    try {
      if (_replyingTo == null) {
        await db.addComment(widget.post.id, text);
        _showNotification("Comment posted");
      } else {
        await db.addCommentReply(_replyingTo!.id, text);
        _showNotification("Reply posted");
      }

      _controller.clear();
      _focusNode.unfocus();
      setState(() => _replyingTo = null);
    } catch (_) {}
    setState(() => _isPosting = false);
  }

  Future<void> _handleDeleteComment(Comment comment) async {
    final db = Provider.of<DatabaseProvider>(context, listen: false);
    await db.deleteComment(comment.id, widget.post.id);
    _showNotification("Comment deleted");
  }

  Future<void> _handleDeleteReply(String parentCommentId, Comment reply) async {
    final db = Provider.of<DatabaseProvider>(context, listen: false);
    await db.deleteCommentReply(parentCommentId, reply.id);
    _showNotification("Reply deleted");
  }

  Future<void> _handleToggleLikeComment(Comment comment) async {
    final db = Provider.of<DatabaseProvider>(context, listen: false);
    final uid = FirebaseAuth.instance.currentUser?.uid;
    if (uid == null) return;
    await db.toggleLikeComment(comment.postId, comment.id, uid);
  }

  Future<void> _handleToggleLikeReply(String parentCommentId, Comment reply) async {
    final db = Provider.of<DatabaseProvider>(context, listen: false);
    final uid = FirebaseAuth.instance.currentUser?.uid;
    if (uid == null) return;
    await db.toggleLikeCommentReply(parentCommentId, reply.id, uid);
  }

  void _startReplying(Comment comment) {
    HapticFeedback.selectionClick();
    setState(() => _replyingTo = comment);
    _focusNode.requestFocus();
  }

  @override
  Widget build(BuildContext context) {
    final db = Provider.of<DatabaseProvider>(context);
    final comments = db.getComments(widget.post.id);
    final currentUserId = FirebaseAuth.instance.currentUser?.uid;
    final colorScheme = Theme.of(context).colorScheme;

    return GestureDetector(
      onVerticalDragUpdate: (details) {
        if (details.primaryDelta != null && details.primaryDelta! > 10) {
          Navigator.of(context).pop();
        }
      },
      child: DraggableScrollableSheet(
        initialChildSize: 0.95,
        minChildSize: 0.5,
        maxChildSize: 0.95,
        expand: false,
        builder: (context, scrollController) {
          return Container(
            decoration: BoxDecoration(
              color: Theme.of(context).scaffoldBackgroundColor,
              borderRadius: const BorderRadius.vertical(top: Radius.circular(36)),
              boxShadow: const [BoxShadow(color: Colors.black26, blurRadius: 12, offset: Offset(0, -4))],
            ),
            clipBehavior: Clip.antiAlias,
            child: Column(
              children: [
                Container(
                  width: 48,
                  height: 6,
                  margin: const EdgeInsets.only(top: 16, bottom: 12),
                  decoration: BoxDecoration(
                    color: Colors.grey[400],
                    borderRadius: BorderRadius.circular(100),
                  ),
                ),
                Text(
                  "Comments",
                  style: Theme.of(context).textTheme.titleMedium?.copyWith(fontWeight: FontWeight.w600),
                ),
                const SizedBox(height: 6),
                Divider(
                  thickness: 0.5,
                  color: Colors.grey.withOpacity(0.4),
                  indent: 100,
                  endIndent: 100,
                ),
                Expanded(
                  child: comments.isEmpty
                      ? Center(child: Text("No comments yet...", style: TextStyle(color: Colors.grey[600])))
                      : ListView.builder(
                          controller: scrollController,
                          physics: const BouncingScrollPhysics(),
                          padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 10),
                          itemCount: comments.length,
                          itemBuilder: (context, index) {
                            final comment = comments[index];
                            final replies = db.getCommentReplies(comment.id);

                            return MyCommentTile(
                              username: comment.username,
                              comment: comment.message,
                              isOwnComment: comment.uid == currentUserId,
                              isLiked: comment.likedBy.contains(currentUserId),
                              commentLikeCount: comment.commentLikeCount,
                              onLikeToggle: () => _handleToggleLikeComment(comment),
                              replies: replies,
                              onReplyTap: () => _startReplying(comment),
                              onDeleteReply: (reply) => _showCommentOptions(reply, parentCommentId: comment.id),
                              onLikeReply: (reply) => _handleToggleLikeReply(comment.id, reply),
                              currentUserId: currentUserId ?? "",
                              onLongPress: () => _showCommentOptions(comment),
                              timestamp: comment.timestamp.toDate(),
                            );
                          },
                        ),
                ),
                if (_replyingTo != null)
                  Container(
                    color: colorScheme.surfaceVariant.withOpacity(0.15),
                    padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
                    child: Row(
                      children: [
                        Expanded(
                          child: Text(
                            "Replying to @${_replyingTo!.username}",
                            style: TextStyle(color: colorScheme.primary, fontWeight: FontWeight.w500),
                          ),
                        ),
                        IconButton(
                          icon: const Icon(Icons.close),
                          onPressed: () => setState(() => _replyingTo = null),
                        ),
                      ],
                    ),
                  ),
                AnimatedPadding(
                  duration: const Duration(milliseconds: 150),
                  curve: Curves.easeOut,
                  padding: EdgeInsets.only(bottom: MediaQuery.of(context).viewInsets.bottom),
                  child: SafeArea(
                    top: false,
                    child: Container(
                      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 10),
                      decoration: BoxDecoration(
                        border: Border(top: BorderSide(color: colorScheme.outline.withOpacity(0.1))),
                        color: colorScheme.surface,
                        boxShadow: [
                          BoxShadow(
                            color: Colors.black.withOpacity(0.05),
                            blurRadius: 6,
                            offset: const Offset(0, -2),
                          )
                        ],
                      ),
                      child: Row(
                        children: [
                          const CircleAvatar(
                            radius: 18,
                            backgroundColor: Colors.grey,
                            child: Icon(Icons.person, color: Colors.white, size: 18),
                          ),
                          const SizedBox(width: 12),
                          Expanded(
                            child: TextField(
                              controller: _controller,
                              focusNode: _focusNode,
                              minLines: 1,
                              maxLines: 4,
                              enabled: !_isPosting,
                              onChanged: (_) => setState(() {}),
                              style: TextStyle(color: colorScheme.onSurface),
                              decoration: InputDecoration(
                                hintText: _replyingTo == null ? "Add a comment..." : "Add a reply...",
                                hintStyle: TextStyle(color: colorScheme.onSurface.withOpacity(0.5)),
                                filled: true,
                                fillColor: colorScheme.surfaceVariant.withOpacity(0.2),
                                contentPadding: const EdgeInsets.symmetric(vertical: 10, horizontal: 14),
                                border: OutlineInputBorder(
                                  borderRadius: BorderRadius.circular(16),
                                  borderSide: BorderSide.none,
                                ),
                              ),
                            ),
                          ),
                          const SizedBox(width: 10),
                          InkWell(
                            borderRadius: BorderRadius.circular(12),
                            onTap: _isPosting || _controller.text.trim().isEmpty
                                ? null
                                : _submitCommentOrReply,
                            child: AnimatedSwitcher(
                              duration: const Duration(milliseconds: 200),
                              transitionBuilder: (child, animation) =>
                                  ScaleTransition(scale: animation, child: child),
                              child: _controller.text.trim().isEmpty
                                  ? Icon(Icons.emoji_emotions_outlined,
                                      key: const ValueKey("emoji"),
                                      color: colorScheme.primary)
                                  : Container(
                                      key: const ValueKey("send"),
                                      decoration: BoxDecoration(
                                        color: Colors.deepPurple,
                                        borderRadius: BorderRadius.circular(12),
                                        boxShadow: [
                                          BoxShadow(
                                            color: Colors.deepPurple.withOpacity(0.5),
                                            blurRadius: 6,
                                            offset: const Offset(0, 2),
                                          ),
                                        ],
                                      ),
                                      padding: const EdgeInsets.all(8),
                                      child: const Icon(Icons.arrow_upward_rounded,
                                          color: Colors.white, size: 22),
                                    ),
                            ),
                          ),
                        ],
                      ),
                    ),
                  ),
                ),
              ],
            ),
          );
        },
      ),
    );
  }
}


import 'package:flutter/material.dart';
import 'package:flutter/services.dart'; // For haptic feedback
import 'package:social_media/Components/brick/comment_like_animation.dart';
import 'package:social_media/models/comment.dart';

class MyCommentTile extends StatefulWidget {
  final String username;
  final String comment;
  final bool isOwnComment;
  final VoidCallback onLongPress;
  final bool isLiked;
  final int commentLikeCount;
  final VoidCallback onLikeToggle;

  final List<Comment> replies;
  final VoidCallback onReplyTap;
  final void Function(Comment reply) onDeleteReply;
  final void Function(Comment reply) onLikeReply;
  final String currentUserId;

  final String? replyingToUsername;
  final bool isPinned;
  final DateTime timestamp;

  final VoidCallback? onUserTap;

  const MyCommentTile({
    super.key,
    required this.username,
    required this.comment,
    required this.isOwnComment,
    required this.onLongPress,
    required this.isLiked,
    required this.commentLikeCount,
    required this.onLikeToggle,
    this.replies = const [],
    required this.onReplyTap,
    required this.onDeleteReply,
    required this.onLikeReply,
    required this.currentUserId,
    this.replyingToUsername,
    this.isPinned = false,
    required this.timestamp,
    this.onUserTap,
  });

  @override
  State<MyCommentTile> createState() => _MyCommentTileState();
}

class _MyCommentTileState extends State<MyCommentTile> with SingleTickerProviderStateMixin {
  bool _showReplies = false;
  late final AnimationController _animationController;
  late final Animation<double> _repliesHeightFactor;

  @override
  void initState() {
    super.initState();
    _animationController = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 300),
    );
    _repliesHeightFactor = CurvedAnimation(
      parent: _animationController,
      curve: Curves.easeInOut,
    );
  }

  @override
  void dispose() {
    _animationController.dispose();
    super.dispose();
  }

  void _toggleReplies() {
    HapticFeedback.selectionClick(); // Haptic on toggle replies (7)
    setState(() => _showReplies = !_showReplies);
    if (_showReplies) {
      _animationController.forward();
    } else {
      _animationController.reverse();
    }
  }

  

  String _timeAgo(DateTime date) {
    final now = DateTime.now();
    final diff = now.difference(date);

    if (diff.inSeconds < 60) return '${diff.inSeconds}s';
    if (diff.inMinutes < 60) return '${diff.inMinutes}m';
    if (diff.inHours < 24) return '${diff.inHours}h';
    if (diff.inDays < 7) return '${diff.inDays}d';
    if (diff.inDays < 30) return '${(diff.inDays / 7).floor()}w';
    if (diff.inDays < 365) return '${(diff.inDays / 30).floor()}mo';
    return '${(diff.inDays / 365).floor()}y';
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final color = theme.colorScheme;

    final timeAgo = _timeAgo(widget.timestamp);

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        InkWell(
          onLongPress: () {
            HapticFeedback.vibrate(); // Haptic feedback on long press (7)
            widget.onLongPress();
            },
            child: Container(
              margin: const EdgeInsets.symmetric(vertical: 4),
              padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 4),
              decoration: BoxDecoration(
                color: widget.isPinned
                    ? color.primary.withOpacity(0.15)  // Pin highlight (6)
                    : color.surfaceVariant.withOpacity(0.45),
                borderRadius: BorderRadius.circular(10),
                border: widget.isPinned
                    ? Border.all(color: color.primary, width: 1.2)
                    : null,
              ),
              child: Row(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  GestureDetector(
                    onTap: widget.onUserTap,
                    child: Semantics(
                      label: 'User avatar of ${widget.username}',
                      child: const CircleAvatar(
                        radius: 20,
                        backgroundColor: Colors.grey,
                        child: Icon(Icons.person, color: Colors.white),
                      ),
                    ),
                  ),
                  const SizedBox(width: 10),
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Row(
                          children: [
                            GestureDetector(
                              onTap: widget.onUserTap,
                              child: Semantics(
                                button: true,
                                label: 'View profile of ${widget.username}',
                                child: Text(
                                  widget.username,
                                  style: theme.textTheme.labelLarge?.copyWith(
                                    fontWeight: FontWeight.w500,
                                    color: color.primary,
                                  ),
                                ),
                              ),
                            ),
                            const SizedBox(width: 8),
                            Text(
                              timeAgo,
                              style: theme.textTheme.bodySmall?.copyWith(
                                color: color.onSurfaceVariant,
                                fontWeight: FontWeight.w400,
                              ),
                            ),
                            if (widget.isPinned) ...[
                              const SizedBox(width: 10),
                              Transform.rotate(
                                angle: 0.785398, // 45 degrees
                                child: Icon(
                                  Icons.push_pin,
                                  color: color.onSurfaceVariant,
                                  size: 14,
                                ),
                              ),
                            ],
                          ],
                        ),
                        const SizedBox(height: 2),
                        if (widget.replyingToUsername != null)
                          GestureDetector(
                            onTap: widget.onUserTap,
                            child: RichText(
                              text: TextSpan(
                                children: [
                                  TextSpan(
                                    text: '@${widget.replyingToUsername} ',
                                    style: theme.textTheme.bodyMedium?.copyWith(
                                      color: const Color.fromARGB(255, 139, 90, 226),
                                      fontWeight: FontWeight.w600,
                                    ),
                                  ),
                                  TextSpan(
                                    text: widget.comment,
                                    style: theme.textTheme.bodyMedium,
                                  ),
                                ],
                              ),
                            ),
                          )
                        else
                          Text(
                            widget.comment,
                            style: theme.textTheme.bodyMedium?.copyWith(height: 1.3),
                          ),
                        const SizedBox(height: 4),
                        GestureDetector(
                          onTap: widget.onReplyTap,
                          child: Semantics(
                            button: true,
                            label: 'Reply to comment by ${widget.username}',
                            child: Text(
                              "Reply",
                              style: theme.textTheme.bodySmall?.copyWith(
                                fontWeight: FontWeight.w500,
                                color: color.primary,
                              ),
                            ),
                          ),
                        ),
                      ],
                    ),
                  ),
                  Column(
                    children: [
                      CommentLikeAnimation(
                        isLiked: widget.isLiked,
                        onTap: widget.onLikeToggle,
                        size: 20,
                        // semanticLabel:
                        //     widget.isLiked ? 'Unlike comment' : 'Like comment', // Accessibility (1)
                      ),
                      const SizedBox(height: 2),
                      Text(
                        widget.commentLikeCount.toString(),
                        style: theme.textTheme.bodySmall
                            ?.copyWith(color: color.onSurfaceVariant),
                      ),
                    ],
                  ),
                ],
              ),
            ),
          ),

          // View replies button (10)
          if (widget.replies.isNotEmpty)
            Center(
              child: Padding(
                padding: const EdgeInsets.only(left: 38, top: 4, bottom: 4),
                child: Semantics(
                  button: true,
                  label: _showReplies
                      ? "Hide replies"
                      : "View replies (${widget.replies.length})",
                  child: GestureDetector(
                    onTap: _toggleReplies,
                    child: Text(
                      _showReplies
                          ? "Hide replies"
                          : "View replies (${widget.replies.length})",
                      style: theme.textTheme.bodySmall?.copyWith(
                            color: color.primary.withOpacity(0.9),
                            fontWeight: FontWeight.w600,
                          ),
                    ),
                  ),
                ),
              ),
            ),

          // Animated replies list (3)
          SizeTransition(
            sizeFactor: _repliesHeightFactor,
            axisAlignment: -1.0,
            child: Padding(
              padding: const EdgeInsets.only(left: 40),
              child: Column(
                children: widget.replies
                    .map(
                      (reply) => Padding(
                        padding: const EdgeInsets.only(top: 6),
                        child: _buildCommentRow(
                          context,
                          username: reply.username,
                          message: reply.message,
                          isOwn: reply.uid == widget.currentUserId,
                          isLiked: reply.likedBy.contains(widget.currentUserId),
                          likeCount: reply.commentLikeCount,
                          onLike: () => widget.onLikeReply(reply),
                          onReplyTap: widget.onReplyTap,
                          onLongPress: () => widget.onDeleteReply(reply),
                          replyingToUsername: widget.username,
                          isPinned: false,
                          timestamp: reply.timestamp.toDate(),
                          onUserTap: widget.onUserTap,
                        ),
                      ),
                    )
                    .toList(),
              ),
            ),
          ),
        ],
      );
    }

    Widget _buildCommentRow(
      BuildContext context, {
      required String username,
      required String message,
      required bool isOwn,
      required bool isLiked,
      required int likeCount,
      required VoidCallback onLike,
      required VoidCallback onReplyTap,
      required VoidCallback onLongPress,
      String? replyingToUsername,
      required bool isPinned,
      required DateTime timestamp,
      VoidCallback? onUserTap,
    }) {
      final theme = Theme.of(context);
      final color = theme.colorScheme;

      final timeAgo = _timeAgo(timestamp);

      return InkWell(
        onLongPress: () {
          HapticFeedback.vibrate(); // Haptic on long press (7)
          onLongPress();
        },
        child: Container(
          margin: const EdgeInsets.symmetric(vertical: 4),
          padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 4),
          decoration: BoxDecoration(
            color: isPinned
                ? color.primary.withOpacity(0.15) // Pin highlight (6)
                : color.surfaceVariant.withOpacity(0.45),
            borderRadius: BorderRadius.circular(10),
            border: isPinned ? Border.all(color: color.primary, width: 1.2) : null,
          ),
          child: Row(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              GestureDetector(
                onTap: onUserTap,
                child: Semantics(
                  label: 'User avatar of $username',
                  child: const CircleAvatar(
                    radius: 20,
                    backgroundColor: Colors.grey,
                    child: Icon(Icons.person, color: Colors.white),
                  ),
                ),
              ),
              const SizedBox(width: 10),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Row(
                      children: [
                        GestureDetector(
                          onTap: onUserTap,
                          child: Semantics(
                            button: true,
                            label: 'View profile of $username',
                            child: Text(
                              username,
                              style: theme.textTheme.labelLarge?.copyWith(
                                fontWeight: FontWeight.w500,
                                color: color.primary,
                              ),
                            ),
                          ),
                        ),
                        const SizedBox(width: 8),
                        Text(
                          timeAgo,
                          style: theme.textTheme.bodySmall?.copyWith(
                            color: color.onSurfaceVariant,
                            fontWeight: FontWeight.w400,
                          ),
                        ),
                        if (isPinned) ...[
                          const SizedBox(width: 10),
                          Transform.rotate(
                            angle: 0.785398,
                            child: Icon(
                              Icons.push_pin,
                              color: color.onSurfaceVariant,
                              size: 14,
                            ),
                          ),
                        ],
                      ],
                    ),
                    const SizedBox(height: 2),
                    if (replyingToUsername != null)
                      GestureDetector(
                        onTap: onUserTap,
                        child: RichText(
                          text: TextSpan(
                            children: [
                              TextSpan(
                                text: '@$replyingToUsername ',
                                style: theme.textTheme.bodyMedium?.copyWith(
                                  color: const Color.fromARGB(255, 139, 90, 226),
                                  fontWeight: FontWeight.w600,
                                ),
                              ),
                              TextSpan(
                                text: message,
                                style: theme.textTheme.bodyMedium,
                              ),
                            ],
                          ),
                        ),
                      )
                    else
                      Text(
                        message,
                        style: theme.textTheme.bodyMedium?.copyWith(height: 1.3),
                      ),
                    const SizedBox(height: 4),
                    GestureDetector(
                      onTap: onReplyTap,
                      child: Semantics(
                        button: true,
                        label: 'Reply to comment by $username',
                        child: Text(
                          "Reply",
                          style: theme.textTheme.bodySmall?.copyWith(
                            fontWeight: FontWeight.w500,
                            color: color.primary,
                          ),
                        ),
                      ),
                    ),
                  ],
                ),
              ),
              Column(
                children: [
                  CommentLikeAnimation(
                    isLiked: isLiked,
                    onTap: onLike,
                    size: 20,
                    // semanticLabel:
                    //     isLiked ? 'Unlike comment' : 'Like comment', // Accessibility (1)
                  ),
                  const SizedBox(height: 2),
                  Text(
                    likeCount.toString(),
                    style: theme.textTheme.bodySmall
                        ?.copyWith(color: color.onSurfaceVariant),
                  ),
                ],
              ),
            ],
          ),
        ),
      );
    }
  }


import 'dart:async';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/material.dart';
import 'package:social_media/models/comment.dart';
import 'package:social_media/models/post.dart';
import 'package:social_media/models/user.dart';
import 'package:social_media/services/auth/auth_service.dart';
import 'package:social_media/services/database/database_service.dart';

class DatabaseProvider extends ChangeNotifier {
  
  final _db = DatabaseService();
  final _auth = AuthService();
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;

  // Subscriptions for real-time updates of comments, replies, and posts
  final Map<String, StreamSubscription> _commentsSubs = {};
  final Map<String, StreamSubscription> _repliesSubs = {};
  StreamSubscription? _postsSubscription;

  // List holding all posts locally
  List<Post> _allPosts = [];
  List<Post> get allPosts => _allPosts;

  // Set of post IDs liked by current user for quick lookup
  final Set<String> _userLikedPosts = {};

  DatabaseProvider() {
    _initialize();
  }

  // Initialize listeners for posts and set up data caches
  void _initialize() {
    startListeningToPosts();
  }

  @override
  void dispose() {
    _commentsSubs.values.forEach((sub) => sub.cancel());
    _repliesSubs.values.forEach((sub) => sub.cancel());
    _postsSubscription?.cancel();
    super.dispose();
  }

  /* ==================== */
  /* === USER PROFILE === */
  /* ==================== */

  /// Fetch a user profile by UID
  Future<UserProfile?> userProfile(String uid) => _db.getUserFromFirebase(uid);

  /// Update the user's bio text
  Future<bool> updateBio(String bio) async {
    try {
      await _db.updateUserBioInFirebase(bio);
      return true;
    } catch (e) {
      debugPrint('Bio update failed: $e');
      return false;
    }
  }

  /* ================= */
  /* === POSTS ======= */
  /* ================= */

  /// Create a new post with a message
  Future<bool> postMessage(String message) async {
    try {
      await _db.postMessageInFirebase(message);
      return true;
    } catch (e) {
      debugPrint('Post creation failed: $e');
      return false;
    }
  }

  /// Load all posts from Firestore (non-stream method)
  Future<void> loadAllPosts() async {
    try {
      _allPosts = await _db.getAllPostsFromFirebase();
      _updateUserLikedPostsCache();
      notifyListeners();
    } catch (e) {
      debugPrint('Post loading failed: $e');
    }
  }

  /// Filter posts to only those created by a particular user
  List<Post> filterUserPosts(String uid) =>
      _allPosts.where((post) => post.uid == uid).toList();

  /// Delete a post by its ID and refresh posts
  Future<bool> deletePost(String postId) async {
    try {
      await _db.deletePostFromFirebase(postId);
      await loadAllPosts();
      return true;
    } catch (e) {
      debugPrint('Post deletion failed: $e');
      return false;
    }
  }

  /* ==================== */
  /* === LIKES ON POSTS == */
  /* ==================== */

  /// Check if current user liked a post (fast lookup)
  bool isPostLikedByCurrentUser(String postId) => _userLikedPosts.contains(postId);

  /// Update local cache of liked posts for current user
  void _updateUserLikedPostsCache() {
    final currentUser = _auth.getCurrentUid();
    if (currentUser == null) return;

    _userLikedPosts.clear();

    for (final post in _allPosts) {
      if (post.likedBy.contains(currentUser)) {
        _userLikedPosts.add(post.id);
      }
    }
  }

  /// Toggle like/unlike for a post
  ///
  /// Updates both `likedBy` list and `likeCount` integer atomically in Firestore.
  /// Also updates local cache and UI optimistically.
  Future<void> toggleLike(String postId) async {
    final currentUser = _auth.getCurrentUid();
    if (currentUser == null) return;

    final postIndex = _allPosts.indexWhere((p) => p.id == postId);
    if (postIndex == -1) return;

    final post = _allPosts[postIndex];
    final userLiked = post.likedBy.contains(currentUser);

    // Prepare updated likedBy list and likeCount
    final List<String> updatedLikedBy = List<String>.from(post.likedBy);
    int updatedLikeCount = post.likeCount;

    if (userLiked) {
      updatedLikedBy.remove(currentUser);
      updatedLikeCount = (updatedLikeCount > 0) ? updatedLikeCount - 1 : 0;
    } else {
      updatedLikedBy.add(currentUser);
      updatedLikeCount += 1;
    }

    // Optimistically update local post data
    final updatedPost = Post(
      id: post.id,
      uid: post.uid,
      name: post.name,
      username: post.username,
      message: post.message,
      timestamp: post.timestamp,
      likedBy: updatedLikedBy,
      likeCount: updatedLikeCount, 
      commentCount: post.commentCount,
      // Keep other fields unchanged if any
      // Add any other Post fields here if your Post model has more
    );

    _allPosts[postIndex] = updatedPost;

    // Update liked posts cache
    if (userLiked) {
      _userLikedPosts.remove(postId);
    } else {
      _userLikedPosts.add(postId);
    }

    notifyListeners();

    // Firestore transaction to update atomically
    final postRef = _firestore.collection('Posts').doc(postId);

    try {
      await _firestore.runTransaction((transaction) async {
        final snapshot = await transaction.get(postRef);
        if (!snapshot.exists) throw Exception('Post not found');

        final List<dynamic> currentLikedBy =
            List<dynamic>.from(snapshot.get('likedBy') ?? []);
        int currentLikeCount = snapshot.get('likeCount') ?? 0;

        if (userLiked) {
          currentLikedBy.remove(currentUser);
          currentLikeCount = (currentLikeCount > 0) ? currentLikeCount - 1 : 0;
        } else {
          currentLikedBy.add(currentUser);
          currentLikeCount += 1;
        }

        transaction.update(postRef, {
          'likedBy': currentLikedBy,
          'likeCount': currentLikeCount,
        });
      });
    } catch (e) {
      debugPrint('Failed to toggle like: $e');

      // Revert local changes on failure
      _allPosts[postIndex] = post;
      if (userLiked) {
        _userLikedPosts.add(postId);
      } else {
        _userLikedPosts.remove(postId);
      }
      notifyListeners();
    }
  }

  /* =================== */
  /* === COMMENTS ====== */
  /* =================== */

  final Map<String, List<Comment>> _comments = {};
  final Map<String, DocumentSnapshot?> _lastCommentDoc = {};
  final Map<String, bool> _hasMoreComments = {};
  final int _commentsPerPage = 15;

  List<Comment> getComments(String postId) => _comments[postId] ?? [];
  bool hasMoreComments(String postId) => _hasMoreComments[postId] ?? true;

  /// Load initial comments page for post
  Future<void> loadComments(String postId) async {
    _comments[postId] = [];
    _lastCommentDoc[postId] = null;
    _hasMoreComments[postId] = true;
    await loadMoreComments(postId);
  }

  /// Load more comments (pagination)
  Future<void> loadMoreComments(String postId) async {
    if (!(_hasMoreComments[postId] ?? true)) return;

    Query query = _firestore
        .collection('Comments')
        .where('postId', isEqualTo: postId)
        .orderBy('isPinned', descending: true)
        .orderBy('timestamp', descending: true)
        .limit(_commentsPerPage);

    if (_lastCommentDoc[postId] != null) {
      query = query.startAfterDocument(_lastCommentDoc[postId]!);
    }

    final snapshot = await query.get();

    if (snapshot.docs.isEmpty) {
      _hasMoreComments[postId] = false;
      notifyListeners();
      return;
    }

    final newComments = snapshot.docs.map(Comment.fromDocument).toList();
    _comments[postId] = [...(_comments[postId] ?? []), ...newComments];
    _lastCommentDoc[postId] = snapshot.docs.last;
    _hasMoreComments[postId] = newComments.length >= _commentsPerPage;
    notifyListeners();
  }


  /// Add a new comment to a post and increment the commentCount in the post
Future<bool> addComment(String postId, String message) async {
  final currentUser = FirebaseAuth.instance.currentUser;
  if (currentUser == null) return false;

  try {
    // Create new Comment object
    final comment = Comment(
      id: '', // Firestore will auto-generate
      postId: postId,
      uid: currentUser.uid,
      name: currentUser.displayName ?? "Anonymous",
      username: currentUser.displayName ?? "user",
      message: message,
      timestamp: Timestamp.now(),
    );

    // Add comment to the Comments collection
    final commentRef = await _db.addCommentInFirebase(postId, message);

    // Increment commentCount atomically in the Posts collection
    final postRef = _firestore.collection('Posts').doc(postId);
    await postRef.update({'commentCount': FieldValue.increment(1)});

    // Reload comments locally for UI
    await loadComments(postId);

    return true;
  } catch (e) {
    debugPrint('Failed to add comment: $e');
    return false;
  }
}

/// Delete a comment and decrement commentCount in the post
Future<bool> deleteComment(String commentId, String postId) async {
  try {
    // Delete comment from Comments collection
    await _db.deleteCommentInFirebase(commentId);

    // Decrement commentCount atomically in the Posts collection
    final postRef = _firestore.collection('Posts').doc(postId);
    await postRef.update({'commentCount': FieldValue.increment(-1)});

    // Reload comments locally for UI
    await loadComments(postId);

    return true;
  } catch (e) {
    debugPrint('Failed to delete comment: $e');
    return false;
  }
}


  


  // /// Add new comment to post
  // Future<bool> addComment(String postId, String message) async {
  //   try {
  //     await _db.addCommentInFirebase(postId, message);
  //     await loadComments(postId);
  //     return true;
  //   } catch (e) {
  //     debugPrint('Comment add failed: $e');
  //     return false;
  //   }
  // }

  // /// Delete a comment and reload
  // Future<bool> deleteComment(String commentId, String postId) async {
  //   try {
  //     await _db.deleteCommentInFirebase(commentId);
  //     await loadComments(postId);
  //     return true;
  //   } catch (e) {
  //     debugPrint('Comment delete failed: $e');
  //     return false;
  //   }
  // }

  /// Toggle like on a comment, updating likedBy list and likeCount integer
  Future<void> toggleLikeComment(
      String postId, String commentId, String userId) async {
    final comments = _comments[postId];
    if (comments == null) return;

    final index = comments.indexWhere((c) => c.id == commentId);
    if (index == -1) return;

    final comment = comments[index];
    final userLiked = comment.likedBy.contains(userId);

    final List<String> updatedLikedBy = List<String>.from(comment.likedBy);
    int updatedLikeCount = comment.commentLikeCount;

    if (userLiked) {
      updatedLikedBy.remove(userId);
      updatedLikeCount = (updatedLikeCount > 0) ? updatedLikeCount - 1 : 0;
    } else {
      updatedLikedBy.add(userId);
      updatedLikeCount += 1;
    }

    // Create a new Comment instance with updated fields
    final updatedComment = Comment(
      id: comment.id,
      postId: comment.postId,
      uid: comment.uid,
      name: comment.name,
      username: comment.username,
      message: comment.message,
      timestamp: comment.timestamp,
      likedBy: updatedLikedBy,
      commentLikeCount: updatedLikeCount,
      commentReplyCount: comment.commentReplyCount,
      isPinned: comment.isPinned,
    );

    comments[index] = updatedComment;
    notifyListeners();

    try {
      await _db.updateCommentLikesInFirebase(
        commentId,
        updatedLikeCount,
        updatedLikedBy,
      );
    } catch (e) {
      debugPrint('Comment like failed: $e');
    }
  }

  /// Toggle pin status for a comment (used by post owner)
  Future<void> togglePinComment({
    required String postId,
    required String commentId,
    required bool newPinState,
  }) async {
    try {
      await _db.setPinComment(
        postId: postId,
        commentId: commentId,
        pin: newPinState,
      );
      await loadComments(postId);
    } catch (e) {
      debugPrint('Comment pin failed: $e');
    }
  }

  /* ================== */
  /* === REPLIES ====== */
  /* ================== */

  final Map<String, List<Comment>> _commentReplies = {};

  List<Comment> getCommentReplies(String commentId) =>
      _commentReplies[commentId] ?? [];

  Future<void> loadCommentReplies(String commentId) async {
    try {
      _commentReplies[commentId] = await _db.getCommentRepliesFromFirebase(commentId);
      notifyListeners();
    } catch (e) {
      debugPrint('Reply loading failed: $e');
    }
  }

  Future<bool> addCommentReply(String commentId, String message) async {
    try {
      await _db.addCommentReplyInFirebase(commentId, message);
      await loadCommentReplies(commentId);
      return true;
    } catch (e) {
      debugPrint('Reply add failed: $e');
      return false;
    }
  }

  Future<bool> deleteCommentReply(String commentId, String replyId) async {
    try {
      await _db.deleteCommentReplyInFirebase(commentId, replyId);
      await loadCommentReplies(commentId);
      return true;
    } catch (e) {
      debugPrint('Reply delete failed: $e');
      return false;
    }
  }

  Future<void> toggleLikeCommentReply(
      String commentId, String replyId, String userId) async {
    final replies = _commentReplies[commentId];
    if (replies == null) return;

    final index = replies.indexWhere((r) => r.id == replyId);
    if (index == -1) return;

    final reply = replies[index];
    final userLiked = reply.likedBy.contains(userId);

    final List<String> updatedLikedBy = List<String>.from(reply.likedBy);
    int updatedLikeCount = reply.commentLikeCount;

    if (userLiked) {
      updatedLikedBy.remove(userId);
      updatedLikeCount = (updatedLikeCount > 0) ? updatedLikeCount - 1 : 0;
    } else {
      updatedLikedBy.add(userId);
      updatedLikeCount += 1;
    }

    final updatedReply = Comment(
      id: reply.id,
      postId: reply.postId,
      uid: reply.uid,
      name: reply.name,
      username: reply.username,
      message: reply.message,
      timestamp: reply.timestamp,
      likedBy: updatedLikedBy,
      commentLikeCount: updatedLikeCount,
      commentReplyCount: reply.commentReplyCount,
      isPinned: reply.isPinned,
    );

    replies[index] = updatedReply;
    notifyListeners();

    try {
      await _db.updateCommentReplyLikesInFirebase(
        commentId,
        replyId,
        updatedLikeCount,
        updatedLikedBy,
      );
    } catch (e) {
      debugPrint('Reply like failed: $e');
    }
  }

  /* ======================= */
  /* === REAL-TIME STREAMS == */
  /* ======================= */

  /// Stream of all posts ordered by timestamp descending
  Stream<List<Post>> postsStream() => _firestore
      .collection('Posts')
      .orderBy('timestamp', descending: true)
      .snapshots()
      .map((snapshot) => snapshot.docs.map(Post.fromDocument).toList());

  /// Listen to post changes in real-time
  void startListeningToPosts() {
    _postsSubscription?.cancel();
    _postsSubscription = postsStream().listen((posts) {
      _allPosts = posts;
      _updateUserLikedPostsCache();
      notifyListeners();
    });
  }

  /// Stream of comments for a post, ordered by pinned and timestamp descending
  Stream<List<Comment>> commentsStream(String postId) => _firestore
      .collection('Comments')
      .where('postId', isEqualTo: postId)
      .orderBy('isPinned', descending: true)
      .orderBy('timestamp', descending: true)
      .snapshots()
      .map((snapshot) => snapshot.docs.map(Comment.fromDocument).toList());

  /// Start listening to comments updates for a specific post
  void listenToComments(String postId) {
    _commentsSubs[postId]?.cancel();
    _commentsSubs[postId] = commentsStream(postId).listen((comments) {
      _comments[postId] = comments;
      notifyListeners();
    });
  }

  /// Stream of replies for a specific comment
  Stream<List<Comment>> commentRepliesStream(String commentId) => _firestore
      .collection('Comments')
      .doc(commentId)
      .collection('CommentReply')
      .orderBy('timestamp', descending: true)
      .snapshots()
      .map((snapshot) => snapshot.docs.map(Comment.fromDocument).toList());

  /// Start listening to replies updates for a comment
  void listenToReplies(String commentId) {
    _repliesSubs[commentId]?.cancel();
    _repliesSubs[commentId] = commentRepliesStream(commentId).listen((replies) {
      _commentReplies[commentId] = replies;
      notifyListeners();
    });
  }

  int getLikeCount(String postId) {
  try {
    final post = _allPosts.firstWhere((p) => p.id == postId);
    return post.likeCount;
  } catch (e) {
    return 0;
  }
}

  String? get currentUserId => _auth.getCurrentUid();

  // other experiment

  
}

updated with commentCount

